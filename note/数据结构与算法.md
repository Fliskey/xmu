# 数据结构与算法



## 导论



## 顺序表



## 树

#### 树的定义表示

- 递归性质

- 层次结构
  - 树的定义

    - n个结点的有限集合（n>=0）

    - 空树：n=0
- 根结点
  
    - 没有前驱的结点
- 前驱后继
  
    - n>1时，除根节点外的结点都有且只有一个前驱

    - 每个结点可以有若干个后继
- 递归定义，一棵树有若干棵互不相交的子树
- 树的表示方法

  - 图
  - 字符形式
    - 进一级加一个括号
  
    - 可做 #串 运算
      - 嵌套集合形式
  - 凹入方式

#### 树的基本概念

  - 树的结点

    - 包含一个数据元素及若干个指针
    
    - 这些指针指向其拥有子树的根
  
  - 结点的度
    - 结点拥有子树的个数
  
  - 叶结点（子结点）
    - 度=0的结点
  
  - 分支结点
    - 度>0的结点
  
  - 树的度 （宽度）
    - max（结点的度）
  
  - 结点的孩子
  
    - 该结点指针指向的结点
    
    - 结点拥有的子树的根
  
  - 孩子的双亲
    - 孩子节点的前驱（结点）
  
  - 兄弟结点
    - 同一个双亲结点的孩子
  
  - 结点的层次
  
    - 根结点定义为第一层
    
    - 根结点的孩子定义为第二层
    
    - 第l层结点的孩子定义为第l+1层
  
  - 树的高度/深度
    - max（结点层次）
  
  - 有序树&无序树
    - 按一定次序从左到右排列的树是有序树
  
  - 森林
    - 若干互不相交的树的有限集
  
  - 注意！
    - 树的高度 和 树的度 是不同概念！

  ### 二叉树

  - 定义
  
    - 结点的度<=2的有序树
    
    - 每个结点的子树最多2棵
  
  - 五种基本形态
  
    - 1. 空
    
    - 2. 单结点
    
    - 3. 根加左子树
    
    - 4. 根加右子树
    
    - 5. 根加左右子树

#### 特殊二叉树

  - 满二叉树
    
  - 高度为k且具有2^k-1个结点的二叉树
    
  - 完全二叉树
  
    - 一颗高度为k，结点个数∈[2^(k-1),2^k-1]，第k层结点都集中在左侧的二叉树
    
    - 满二叉树也是完全二叉树

#### 性质

  - 二叉树在第i层上最多有2^(i-1)个结点
    
    - 高度为k的二叉树最多有2^k-1个结点
    
    - 如果二叉树叶子节点的个数为n0，度数为2的节点数为n2，则n0=n2+1
      
    - 结点个数=边的条数+1
      
    - n个结点的完全二叉树的高度为 floor( log2(n) )+1
    
    - 完全二叉树（n结点）
    
      - 1. 编号i = 1：根结点
    
           编号i > 1：双亲编号floor(i/2)
    
      - 2. 结点i左孩子编号2i
    
           结点i右孩子编号2i+1
    
      - 3. 如果2i <= n，i为分支结点
    
           如果2i > n，i为叶子结点
    
      - 4. 如果n为奇数，则每个结点都有左右孩子
    
           如果n为偶数，则编号为n/2的分支结点（最大的分支结点）只有左孩子没有右孩子

#### 顺序存储结构

  - 由上而下，由左往右进行顺序存放
  - 对一般的二叉树，用顺序存储会造成大量空间浪费
  - 适合完全二叉树

#### 链式存储结构

  - 定义结点

```c
typedef struct Tnode{
Type data;
struct Tnode *lc;//左子树
struct Tnode *rc;//右子树
}Tnode,*Tree;
```

- 建树：给头结点malloc，指向子树的指针给NULL

- ```c
  InitTree(Tree &T)
  ```

- 补充：参数传递

- ```c
  swap(int a,int b)//分别给两个形式参数复制数，随着函数结束消失
  swap(int &a,int &b)//传两个地址给a和b的地址空间
  ```

- 读字符串并存入二叉树

  - data存一个字母
  - 左右孩子用，分隔
  - 只有左子树(a,) (a)
  - 只有右子树(,b)
- 实现
  - 字母模块，申结点空间，给该结点赋值，链入树中
  - 右子树则链入右，左子树则先链入后递归



### ==期中考==

11月10号周二下午考试

考试范围从绪论到树

简答题6 算法设计题4 总分100 折算20%



### 二叉树的遍历

逐个访问二叉树可视作化顺序表

#### 先序遍历

DLR 根-左-右

字符型建树

Z字形

#### 中序遍历

LDR 左-根-右

锯齿形

#### 后序遍历

LRD 左-右-根

求树的高度

#### 两遍历序列求原树

中序+先/后序：先找子树的根，分开左右子树

#### 非递归遍历

需要用栈存储遍历路径

```c++
//链栈
typedef struct SNode{
    Tree tnode;
    struct SNode *next;
}*Stark;

//其实就是把递归的栈自己写……会更快
//我太天真了，还是比较难的

int PreOrderS(Tree T){
	StackInit(S);
    p = T->lc;//根在T的左子
    while(p){
        while(p->lc){
            Visit(p);//向左走直接弹出父节点
            Push(S,p);
            p = p->lc;
        }
        Visit(p);
        while(!p->rc){
            Pop(S,p);
        }
        if(p->rc){
            p = p->rc;
        }
    }
}

int InOrder(Tree T){
    StackInit(S);
    p = T->lc;
    while(p){
        while(p->lc){
            Push(S,p);
            p = p->lc;
        }
        Visit(p);
        while(!p->rc){//左子树处理完了，可以弹出父节点
            Pop(S,p);
            Visit(p);
        }
        if(p->rc){
            p = p->rc;
        }
    }
}

//要用两个栈，往左找存左栈，找完弹一个到右栈，往右找完弹右栈
int PostOrder(Tree T){
    StackInit(L);
    StackInit(R);
    p = T->lc;
    while(p){
        while(p->lc){//一路向左压入左栈
            Push(L,p);
            p = p->lc;
        }
        while(!p->rc){//没有右子树，访问节点
            Visit(p);
            while(R->tnode->tc == p){//父节点右子树
                Pop(R,p);
                Visit(p);
            }
        }
        Pop(L,p);
        if(p->rc){
            Push(R,p);
            p = p->rc;
        }
    }
}
```



### 线索二叉树

#### **原理**

二叉树中存在很多空指针（无子树）

（n个结点存在n+1个空指针，数学归纳法证明）

可以利用起来，按遍历顺序的后序结点串起来

遍历时只需要沿着线索走



空右指针域存放后继

空左指针域存放前驱

叶结点的 <u>线索指针</u> 指向后继结点

疑问：如果非叶结点的右子树指针为空怎么办（ppt上的D）

答：照常存



#### **定义**

依据某次遍历

在二叉树中的相关空指针域都写入线索

（后继线索或前驱线索）

即成为线索二叉树



可衍生出（先/中/后）序（前驱/后继）六种



#### 线索化原则

##### 先序后继

右子树根结点链入左子树最后一个叶子结点

##### 中序后继

给定结点x，它是其左子树最后一个叶子节点的后继结点

##### 后序后继

- 若结点x是二叉树的根，则其后继为空
- 若结点x是其双亲的右孩子或其双亲的左孩子且无右孩子，则其后继为双亲结点
- 若结点x是其双亲的左孩子，且双亲有右子树，则其后继为双亲右子树上按后序遍历列出的第一个结点



#### 线索化算法

```c++
//伪代码
typedef struct Node{
    Type data;
    struct Node *lc;
    struct Node *rc
    int Tag;	//0：分支结点，1：叶子结点
}Tnode, *Tree;

int PreOrderT(Tree T){
    StackInit(S);
    p = T->lc;
    p0 = p;	//记录左子树最后一个结点
    while(p){
        while(p->lc){
            Push(S,p);
            p = p->lc;
        }//找到子树最左端，p最后存的是最左，但不一定是最后一个结点
        if(p->rc)//如果p有右子树，挪一位返回第一个while
            p = p->rc;
        else{
            p0 = p;//找到最后一个结点了，保存到p0中
            //线索化
            while(!p->rc)
                Pop(S,p);
            if (p->rc){
                p = p->rc;
                p0->rc = p;
            }
        }
    }
}

//输出后继线索二叉链表
int PreOrderPrint(Tree T){
    p = T->lc;
    while(p){
        Visit(p);
        if(p->lc)
            p = p->lc;
        else
            p = p->rc;
    }
}
```



### 哈夫曼树

#### 引入

**哈夫曼**

Huffman，52年MIT，毕业后在加州大学当老师

香农在48年提出信息论，一套二进制编码

哈夫曼在学这门课程，从大作业和期末考里面选

哈夫曼自己写了一个最优二进制编码

姓氏可追溯到德国，后缀mann（我在DS学德语哈哈哈）

他老师写的二进制编码是定长编码

符号在报文中出现的概率是不一样的，考虑概率因素后，定长编码不具优势

哈夫曼：概率小的用长编码，概率大的用短编码



#### 概念定义

- 路径长度（编码码长）

- 结点权值

- 带权路径长度

  - 从根到叶子结点的路径长度与权之积

- 树的带权路径长度WPL



#### 哈夫曼树算法

挑两个当前最小权重的树合并成新二叉树

新二叉树权重为子树权之和

重复合并，直到最后只有一棵树

##### 性质

n个叶子结点的哈夫曼树，共有2n-1个结点

可以用顺序表（数组）来实现

##### 实现

数据类型：记录数组，指针是数组下标

- 找最小两权重
- 新增结点，放入权重和，存入左右孩子`i = n+1`
- 给左右孩子保存父节点位置
- 重复上述步骤

```c++
typedef struct{
    char data;
    int Wt;
    int Np,Nl,Nr;
}HTree;

HTree Ht[2*N];

void C_HTree(int n){
    s1 = 0;
    s2 = 0;
    for(i=n+1 ; i<=2*n-1 ; i++){
        Select(i,&s1,&s2);
        Ht[i].Wt = Ht[s1].Wt+Ht[s2].Wt;
        Ht[i].Nl = s1;
        Ht[i].Nr = s2;
        Ht[s1].Np = Ht[s2].Np = i;
    }
}
```



#### 哈夫曼编码

##### 前缀编码

任何一个字符的编码都不是另一个字符编码的前缀



##### 译码

从根网上找，倒序排列

```c++
//从叶子结点到根，逆向求每个叶子结点的哈夫曼编码
void C_HuffCode(int n){
    char code[N];	//存放当前叶子结点的哈夫曼编码
	for(i=1 ; i<=n ; i++)
    {
        j=i,k=0;   //从当前叶子结点开始标示
		while(Ht[j].Np>0)
        {
            if(Ht[Ht[j].Np].Nl==j)
                code[k++]='0'; 
			else
                code[k++]=‘1’;	//右支为1
			j=Ht[j].Np;
		}
		printf(“\n%c: ”,Ht[i].data);    //逆向输出编码
		for(j=k-1;j>=0;j--)
            printf("%c",code[j]);
	}
}
```



### 树的存储结构

#### 树的双亲表示法

- 用数组就很好实现，不需要删改
- 举个栗子:chestnut:

| asset | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| data  | a    | b    | c    | d    | e    | f    | g    |
| point | -1   | 0    | 0    | 0    | 2    | 2    | 2    |

```c++
typedef struct Node{
    Type data;  //数据元素
	int parent；//双亲位置
} TNode；//结点结构

typedef struct{
    TNode tree[MaxSize]；
	int nodenum；//结点数
} PTree；//树的存储结构
```

- 特点：方便往上找，往下找很不方便，找一层孩子要遍历一遍



#### 树的孩子表示法

- 每个结点都自带一个链表，来存孩子
- 举个栗子:chestnut:

| asset | data | child1 | child2 | child3 |
| ----- | ---- | ------ | ------ | ------ |
| 0     | a    | 1      | 2      | 3      |
| 1     | b    | ^      |        |        |
| 2     | c    | 4      | 5      | 6      |
| 3     | d    | ^      |        |        |
| 4     | e    | ^      |        |        |
| 5     | f    | ^      |        |        |
| 6     | g    | ^      |        |        |

- 实现
  - 结点间用数组存
  - 结点与孩子用链表串起来，头指针是结点

```c++
typedef  struct  Node{
    int  child；//孩子结点在顺序表中的位置
	struct  Node *next；
}*Tnode；//孩子链表结构

typedef  struct{
    Type  data；
	Tnode  firstchild；//孩子链表头指针
} Tchild；//表头指针结构

typedef  struct{
    Tchild  T[MaxSize]；
	int  r, n；//根的位置，结点数
} CTree；//树的存储结构
```

- 特点：向下找方便，向上找不方便

- 优化：在孩子表示法的基础上再扩一个域，指向父节点
  - 结构是活的 



#### 树的孩子兄弟表示法

##### 即树的二叉链表

对每个结点只保留最左孩子和右兄弟

- 树的二叉链表存储结构

```c++
typedef  struct Tnode{
    Type  data；//数据元素域
	struct Tnode *Child1；//第1个孩子
	struct Tnode *Sibling；//下1个兄弟
} Node，*Tcs；
```

- 二叉链表还原为树（自己的表述）
  - 能向右找的兄弟结点链到父节点上
  - 删除兄弟结点间的联系
  - 即为原树
- 树转化成二叉链表（专业语言）
  - 每层自左向右在兄弟结点之间加虚线
  - 除了最左第一个子结点外，父结点与其他所有的子结点连线去掉
  - 树旋转45°，虚线改为实现
  - 规整化
- 森林转化成二叉树
  - 原理：把森林每棵树的根连起来（视作兄弟）
  - 每棵树转换成二叉树
  - 后树链到前树的右结点（兄弟结点）



### 树的遍历

- 访问树的二叉链表树：

二叉树解读		树解读

先序遍历	->	先根遍历

中序遍历	->	后根遍历



- 层序（层次）遍历
  - 中间结果用队列表示
  - 取出一个结点，该点子结点入队，该点出队
  - 重复过程，直到所有结点出队

