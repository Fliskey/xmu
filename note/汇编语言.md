# 汇编语言

## 第二部分 汇编指令

### 2.1 数据传送类指令

#### 2.1.1通用数据传送类指令

**MOV XCHG XLAT**

##### MOV 传送指令

###### 类型

- 立即数传送`MOV reg/mem,imm`
- 寄存器传送`MOV reg/mem/seg,reg`
- 储存器传送`MOV reg/seg,mem`
- 段寄存器传送`MOV reg/mem,seg`

###### 特点

限制性传送

| From↓    To→ | 通用寄存器 | 段寄存器 | 存储器 |
| ------------ | ---------- | -------- | ------ |
| 立即数       | 1          | 0        | 1      |
| 通用寄存器   | 1          | 1        | 1      |
| 段寄存器     | 1          | 0        | 1      |
| 存储器       | 1          | 1        | 0      |

###### 非法传送

操作数类型不一致

两操作数不能都是存储器

段寄存器的操作有一些限制



##### XCHG 交换指令

格式：`XCHG reg,reg/mem`

寄存器与存储器之间对换数据

不可在存储器之间交换



##### XLAT 换码指令

格式：`XLAT`

将BX指定的缓冲区中，AX指定的位移处的一个字节数据付给AL

相当于`MOV AL,DS:[BX+AL]`



#### 2.1.2 堆栈操作指令

##### PUSH 入栈 POP 出栈

格式：

`PUSH r16/m16/seg`

`POP r16/m16/seg`

例：

```assembly
PUSH AX
PUSH BX
PUSH DS
...
POP DS
POP BX
POP AX
;以此入栈，然后把最上面的弹给DS，再弹给BX，再弹给AX
```



#### 2.1.3 标志传送指令

##### LAHF FLAGS存到AH

##### SAHF AH存到FLAGS

##### PUSHF POPF 栈存FLAGS

##### CLC STC CMC 对CF运算



### 2.2 算术运算类指令



### 2.3 位操作类指令



### 2.4 控制转移类指令

<u>**实现分支、循环、过程等程序结构，仅次于传送指令的常用指令**</u>

重点掌握：`JMP/JCC/LOOP CALL/RET`

一般了解：`LOOPZ/LOOPNZ INTO`

改变IP CS的值实现执行顺序改变

#### 2.4.1 无条件转移指令

##### `JMP`

```assembly
JMP label	;转向label标号指定的地址
```

**四种类型：**

- 段内转移、相对寻址	相对基址寻址

- 段内转移、间接寻址	访存再次访存
  - JMP R16/M16

- 段间转移、直接寻址
  - JMP FAR PTR LABEL

- 段间转移、间接寻址
  - JMP FAR PTR MEM
  - 用一个双字存储单元表示要跳转的目标地址，低位存IP，高位存CS

**目标地址的范围**

- 近转移
  - 短转移
- 远转移



#### 2.4.2 条件转移指令

##### `JCC`

一般都是近转

8位位移量 转移范围不会超过-128~127



不影响标志但利用标志

- **判断单个标志位状态**

  - JZ/JE  JNZ/JNE ： ZF零标志位，结果是否为零（相等）

    - ```assembly
      ;看着像CBW，子夏也说是
      		TEST AL,80H
      		JZ NEXT0
      		MOV AH,0FFH
      		JMP DONE
      NEXT0:	MOV AH,0
      DONE:	...
      ```

    - ```assembly
      ;和上一段功能一致
      		TEST AL,80H
      		JNZ NEXT1
      		MOV AH,0	;和上一段反过来了
      		JMP DONE
      NEXT1:	MOV AH,0FFH
      DONE:	...
      ```

  - JS  JNS ： SF符号标志，结果正负

    - ```assembly
      ;计算X-Y的绝对值
      		MOV AX,X
      		SUB AX,Y
      		JNS NONNEG
      		NEG AX	;求补
      NONNEG:	MOV RESULT,AX
      ;如果时JS，应该是把NONNEG的指令和NEG互换
      ```

  - JO  JNO ： OF溢出标志，结果是否溢出

    - ```assembly
      ;计算X-Y
      			MOV AX,X
      			SUB AX,Y
      			JO OVERFLOW
      			...	;无溢出，结果正确
      OVERFLOW:	...	;有溢出，处理异常
      ```

  - JP/JPE  JNP/JPO ： PF奇偶标志，1的个数时偶还是奇（在串中用到）

    - ```assembly
      ;奇偶校验
      ;ASCII码是7位，加一位奇偶校验位（放在最高位）
      ;保证最终得到的结果，1的个数恒为奇
      		AND AL,7FH	;AL最高位置0
      		JNP NEXT	;1的个数为奇数
      		OR AL,80H	;最高位置1
      NEXT:	...
      ```

  - JC/JB/JNAE  JNC/JNB/JAE ： CF进位标志，判断结果进位还是借位（用到比大小）

    - ```assembly
      ;记录BX中1的个数
      		XOR AL,AL	;异或，AL置0，CF置0
      AGAIN:	TEST BX,0FFFFH	;等价于CMP BX,0  边界条件，BX移完了JE会置位
      		JE NEXT
      		SHL BL,1	;左移一位
      		JNC AGAIN	;CF为0，取出的不是1，则回到AGAIN继续
      		INC AL		;用AL计数
      		JMP AGAIN
      NEXT:	...
      ;也可以用循环16次来控制~
      ```

    - ```assembly
      ;等价的做法，写的更精简
      		XOR AL,AL
      AGAIN:	CMP BX,0
      		JZ NEXT
      		SHL BX,1	;SHR BX,1也是等效的
      		ADC AL,0	;用到进位符
      		JMP AGAIN
      NEXT:	...
      ```

- **比较无符号数高低**

  - 无符号数的大小用高（Above）、低（Below）表示

  - 利用CF确定高低、利用ZF标志确定相等

  - 两数的高低分成4种关系：

    - 低于（不高于等于）：JB（JNAE）<
    - 不低于（高于等于）：JNB（JAE）>=
    - 低于等于（不高于）：JBE（JNA）<=
    - 不低于等于（高于）：JNBE（JA）>

  - ```assembly
    		CMP AX,BX
      		JNB NEXT	;AX>=BX
      		XCHG AX,BX	;交换
    NEXT:	MOV RESULT,AX
    ```

- **比较有符号数大小**

  - 有符号数的大（Great）/小（Less）

  - 需要组合OF、SF标志，利用ZF标志确定相等（Equal）

  - 两数的大小分为4种关系：

    - 小于
    - 不小于
    - 小于等于
    - 不小于等于

  - ```assembly
    		CMP AX,BX
      		JNL NEXT
      		XCHG AX,BX
    NEXT:	MOV RESULT,AX
    ```

#### 2.4.3 循环指令

##### `JCXZ LOOP LOOPZ LOOPNZ`

```assembly
JCXZ LABEL
	;CX置0，转移到label
LOOP LABEL
	;如果CX未归零则继续
LOOPZ LABEL
	;加一条如果ZF为0则提前退出
LOOPNZ LABEL
	;ZF的判断和第三条相反~
```

- 默认用CX计数器

- label用短转移

例子：空格计数

```assembly
		MOV CX,COUNT
		MOV SI,OFFSER STRING	;取它的偏移量
		XOR BX,BX	;清零，来计数，可以用其他方法实现
		JCXZ DONE	;CMP CX,0
					;JZ NEXT
		MOV AL,20H	;空格的ASCII：20H
AGAIN:	CMP AL,ES:[SI]	;寄存器间指，跨段到ES
		JNZ NEXT	;不相等的时候跳
		INC BX		;计数
NEXT:	INC SI		;指针下移1个位置（字符型是1个）
		LOOP AGAIN	;DEC CX（一定要用CX做寄存器才能用LOOP）
					;JNZ AGAIN
DONE:	...
```



#### 2.4.3 子程序指令

##### `CALL RET`

主调子可类比中断

- CALL分为四种类型
  - CALL label	
  - CALL r16/m16
  - CALL far PTR label
  - CALL far PTR mem

- CALL指令需要保存返回地址
  - 段内调用，入栈偏移地址IP
    - SP <- SP-2，SS:[SP] <- IP
  - 段间调用，入栈偏移地址IP和段地址CS
    - SP <- SP-2，SS:[SP] <- IP
    - SP <- SP-2，SS:[SP] <- CS
- RET返回

- 例子

```assembly
;主程序
	MOV AL,0AH
	CALL HTOASC
	
;子程序
HTOASC:	AND AL,0FH
		OR AL,30H
		CMP AL,39H
		JBE HTOEND
		ADD AL,7
HTOEND:	RET
```





#### 2.4.5 中断指令

##### `INT i8 IRET INTO`



8086可管理256个中断（1K），每个中断都用一个向量编号来区别

- 外部中断，CPU原因之外的原因引起的中断
  - 可屏蔽中断（可以不管）
    - 由IF标志控制是否响应中断
  - 非屏蔽中断（必须得管）
    - 不受IF控制
- 内部中断，CPU内部执行程序引起的中断
  - 除法错中断，0号中断
  - 指令中断，i8号中断
  - 断点中断，3号中断
  - 溢出中断，4号中断
  - 单步中断，1号中断

#### 之后老师懒得细讲了



---

## 第三部分 程序设计基础

硬指令：产生CPU动作

伪指令：不产生CPU动作



### 3.1 汇编语言程序的开发

#### 3.1.1语句格式

- 执行性语句
  - `标号: 硬指令助记符 操作数,操作数 ;注释`

- 说明性语句
  - `名字 伪指令助记符 参数,参数,... ;注释`

- 例子：

```assembly
MOV CX,0	;传送指令，具有2个操作数

DELAY:	NOP	;空操作指令，没有操作数，带有标号

LOOP DELAY	;循环指令，标号DELAY说明转移位置

BUFFER	DB 1,2,3,4,5,6,7
;数据定义伪指令，在主存中开辟7个连续的字节单元，初值依次为1～7，BUFFER表示首地址
```

- 标号
  - 反映硬指令位置（逻辑地址）的标识符，后跟一个冒号分隔
- 名字
  - 反映伪指令位置（逻辑地址）和属性的标识符，后根空格或制表符分隔，没有一个冒号
- 标识符
  - Identifier
  - 最多由31个字母、数字，及规定的特殊符号组成，不可以数字开头
  - 特殊符号如 _ $ ? @
  - 不区分大小写
  - 每个标识符的定义是唯一的，不能用保留字
- 保留字
  - 硬指令助记符    MOV  ADD
  - 伪指令标识符    DB  EQU
  - 操作符    OFFSET  PTR
  - 寄存器名
  - 预定义符号
- 操作数与参数
  - 处理器指令的操作数
    - 立即数
    - 寄存器
    - 存储单元
  - 伪指令
    - 常数
    - 变量名
    - 表达式
- 注释
- 分隔符



#### 3.1.2 程序格式

#### 3.1.4 DOS系统功能调用

`INT 21H`，调用AH中的调用号

输入输出类功能

- Ctrl+C或Ctrl+Break结束

- 字符输出
  - 02h
  - DL里的ASCII输出字符
- 字符串输出
  - 09h
  - 以$（24H）结束
  - 字符串偏移地址放到DX里
- 字符输入
  - 01h
  - ASCII码传到AL里
- 字符串输入
  - 0ah
  - 缓冲区首地址DS：DX
- 判断按键
  - 0bh
  - AL=0没有按键
  - AL=FFH有按键