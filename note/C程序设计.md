# C程序设计

## 补充

**数组使用场景**

- 物理意义相同
- 数据类型相同
- 仅有次序区别

**循环使用场景**

- 流程大致相同
- 执行多次
- 有参数区别



## 第八课 - 输入输出与字符验证

### 输入输出缓冲

#### 单字符I/O

```c
ch = getchar();
new_ch = putchar(ch);


while((ch = getchar()) != '\n'){
    ……
}
```

getchar()有缓冲区，输入的数据放到缓冲区，直到输入回车才开始读入，且会读空白字符



#### 缓冲

是内存的一个取余，用于从一个地方移动到另一个位置时临时存储数据

协调吞吐速度差距很大的设备之间数据传送



#### 输入流

缓冲区默认为空

读一个删一个

已空后，若能补充缓冲则暂停等待，否则返回EOF继续冲虚

程序结束后，缓冲区释放



键盘缓冲区

程序缓冲区



#### 输入缓冲

##### 分类

完全缓冲，遇到缓冲区满就发送并清空（文件）

行缓冲，遇到回车时发送并清空（键盘）

##### 优缺点

允许用户在输入结束前发现错误，即使修改

减少调用输入输出的负担（数据库）

交互式程序需要非缓冲



#### 无缓冲输入流的行为

读取一个马上显示（存）一个



#### 输入输出流

（stream）

掩盖底层差异，提供统一接口

替用户和操作系统底层I/O打交道

四个操作，开open、关close、读read、写write

| 常见设备 | 标准流                                 | 打开     | 关闭 | 读取 | 写入 |
| -------- | -------------------------------------- | -------- | ---- | ---- | ---- |
| 屏幕     | 标准输出流stdout<br />标准错误流stderr | 自动打开 | 不可 | 不可 | 可   |
| 键盘     | 标准输入流stdin                        | 自动打开 | 可   | 可   | 不可 |
| 打印机   | 打印流                                 | 可       | 可   | 不可 | 可   |
| 文件     | 文件流                                 | 可       | 可   | 可   | 可   |
| 网络     | 网络流                                 | 可       | 可   | 可   | 可   |



#### 输入流终止

Ctrl+Z 终止键盘输入

Ctrl+C 终止程序终止键盘输入

返回EOF





```c
FILE * fp;
char fname[50];
fp = fopen(fname,"r");
getc(fp);
fclose(fp);
```



#### 流的重定向

用函数重定向到其他流



### 友好用户界面

软件工程更应该注重的地方

- 主体功能时基础

- 软件在用户各种可能的输入下不会崩溃也很重要

解决初级用户的输入错误

- 需要解决多余回车的问题

- 需要解决不慎按错键的问题



要用上`scanf`的返回值

可以用上assert函数：`assert(i-j-1>0 && i-j-1<N)`



## 2048游戏设计

## 作业要求

设计并实现一个2048游戏（大部分的需求都只有一句话）

作业——考核、承载老师对课程的理解

老师对程序设计的理解：

- 满足软件工程相关的思想

## 要求

### 需求分析

需求是不明确的

- 需要由需求分析人员和项目委托方共同完成

- 最终将明确需求为项目合同的附件，按期责功

方法

- 搜索相近产品，进一步细化需求
- 向项目委托方进一步确认

#### 要求

1. 2048有一个4*4棋盘
2. 开始时棋盘内随机出现两个数字，出现数字仅可能为2或4
3. 玩家可以选择上下左右四个方向，棋盘内棋子按该方向位移
   1. 若有棋子在移动方向一侧为空，则将其移动到该位
   2. 若有棋子在移动方向一侧为同样的数字，则将其相加，不可将两个以上数字相加
   3. 若该方向上无棋子满足1或2条件，则不移动棋子
4. 每有效移动一步，棋盘的空位随机出现一个数字（2或4）
5. 若四个方向都满足3.3条件，则判负
6. 若出现2048，则判胜



### 设计

#### 功能设计

**好的架构是进化来的，不是设计来的**

**测试指导编程**

数据结构：4*4矩阵变量

功能1：初始化棋盘，清空，出现两个值，可能为2或4

功能2：显示棋盘，两个for，打印数组，注意对齐

功能3：上下左右位移棋盘，只考虑位移

功能3.1：按行整理棋盘，用于左右位移

功能3.2：按行合并棋子

功能4：随机选择空位，随机增加一个棋子

功能5：判断胜负

#### 模块化设计

自顶向下

- 顶部架构设计，在一步步细化 

自底向上

- 先收集核心代码片段，一步步构造

双管齐下

- 两边同时进行



### 实现

走出第一步

```c
int main(){
    //initialize board
    //display board
    while(1){
        //add a number
        //move by input
        //fill blank
        //display board
        //if it is over, break
    }
    return 0;
}
```

完善框架

```c
int main(){
	initBoard();
    drawBoard();
    while(1){
        c = getInput();
        suc = moveByDirect(c);
        addRandom();
        drawBoard();
        if(gameEnded()){
            showResult();
            break;
        }
    }
    return 0;
}
```

函数列表

- `initBoard`
- `addRandom`
- `drawBoard`
- `getInput`
- `moveByDirect(char)`
- `gameEnded`
- `showResult`



### 测试维护



## 第九课 - 函数

> 高内聚，低耦合
> High cohesion, low coupling



### 函数的组成

#### 函数

完成特定任务的程序代码的自包含单元（自力更生）

- 定义

```c
函数值类型
 |  函数名
 |   |   形式参数列表
 ↓   ↓       ↓
int sum(int a,int b){
    return a+b;
}
```



### 函数的调用



### 递归函数

