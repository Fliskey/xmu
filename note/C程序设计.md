# C程序设计

## 补充

**数组使用场景**

- 物理意义相同
- 数据类型相同
- 仅有次序区别

**循环使用场景**

- 流程大致相同
- 执行多次
- 有参数区别



## 第八课 - 输入输出与字符验证

### 输入输出缓冲

#### 单字符I/O

```c
ch = getchar();
new_ch = putchar(ch);


while((ch = getchar()) != '\n'){
    ……
}
```

getchar()有缓冲区，输入的数据放到缓冲区，直到输入回车才开始读入，且会读空白字符



#### 缓冲

是内存的一个取余，用于从一个地方移动到另一个位置时临时存储数据

协调吞吐速度差距很大的设备之间数据传送



#### 输入流

缓冲区默认为空

读一个删一个

已空后，若能补充缓冲则暂停等待，否则返回EOF继续冲虚

程序结束后，缓冲区释放



键盘缓冲区

程序缓冲区



#### 输入缓冲

##### 分类

完全缓冲，遇到缓冲区满就发送并清空（文件）

行缓冲，遇到回车时发送并清空（键盘）

##### 优缺点

允许用户在输入结束前发现错误，即使修改

减少调用输入输出的负担（数据库）

交互式程序需要非缓冲



#### 无缓冲输入流的行为

读取一个马上显示（存）一个



#### 输入输出流

（stream）

掩盖底层差异，提供统一接口

替用户和操作系统底层I/O打交道

四个操作，开open、关close、读read、写write

| 常见设备 | 标准流                                 | 打开     | 关闭 | 读取 | 写入 |
| -------- | -------------------------------------- | -------- | ---- | ---- | ---- |
| 屏幕     | 标准输出流stdout<br />标准错误流stderr | 自动打开 | 不可 | 不可 | 可   |
| 键盘     | 标准输入流stdin                        | 自动打开 | 可   | 可   | 不可 |
| 打印机   | 打印流                                 | 可       | 可   | 不可 | 可   |
| 文件     | 文件流                                 | 可       | 可   | 可   | 可   |
| 网络     | 网络流                                 | 可       | 可   | 可   | 可   |



#### 输入流终止

Ctrl+Z 终止键盘输入

Ctrl+C 终止程序终止键盘输入

返回EOF





```c
FILE * fp;
char fname[50];
fp = fopen(fname,"r");
getc(fp);
fclose(fp);
```



#### 流的重定向

用函数重定向到其他流



### 友好用户界面

软件工程更应该注重的地方

- 主体功能时基础

- 软件在用户各种可能的输入下不会崩溃也很重要

解决初级用户的输入错误

- 需要解决多余回车的问题

- 需要解决不慎按错键的问题



要用上`scanf`的返回值

可以用上assert函数：`assert(i-j-1>0 && i-j-1<N)`



## 2048游戏设计

## 作业要求

设计并实现一个2048游戏（大部分的需求都只有一句话）

作业——考核、承载老师对课程的理解

老师对程序设计的理解：

- 满足软件工程相关的思想

## 要求

### 需求分析

需求是不明确的

- 需要由需求分析人员和项目委托方共同完成

- 最终将明确需求为项目合同的附件，按期责功

方法

- 搜索相近产品，进一步细化需求
- 向项目委托方进一步确认

#### 要求

1. 2048有一个4*4棋盘
2. 开始时棋盘内随机出现两个数字，出现数字仅可能为2或4
3. 玩家可以选择上下左右四个方向，棋盘内棋子按该方向位移
   1. 若有棋子在移动方向一侧为空，则将其移动到该位
   2. 若有棋子在移动方向一侧为同样的数字，则将其相加，不可将两个以上数字相加
   3. 若该方向上无棋子满足1或2条件，则不移动棋子
4. 每有效移动一步，棋盘的空位随机出现一个数字（2或4）
5. 若四个方向都满足3.3条件，则判负
6. 若出现2048，则判胜



### 设计

#### 功能设计

**好的架构是进化来的，不是设计来的**

**测试指导编程**

数据结构：4*4矩阵变量

功能1：初始化棋盘，清空，出现两个值，可能为2或4

功能2：显示棋盘，两个for，打印数组，注意对齐

功能3：上下左右位移棋盘，只考虑位移

功能3.1：按行整理棋盘，用于左右位移

功能3.2：按行合并棋子

功能4：随机选择空位，随机增加一个棋子

功能5：判断胜负

#### 模块化设计

自顶向下

- 顶部架构设计，在一步步细化 

自底向上

- 先收集核心代码片段，一步步构造

双管齐下

- 两边同时进行



### 实现

走出第一步

```c
int main(){
    //initialize board
    //display board
    while(1){
        //add a number
        //move by input
        //fill blank
        //display board
        //if it is over, break
    }
    return 0;
}
```

完善框架

```c
int main(){
	initBoard();
    drawBoard();
    while(1){
        c = getInput();
        suc = moveByDirect(c);
        addRandom();
        drawBoard();
        if(gameEnded()){
            showResult();
            break;
        }
    }
    return 0;
}
```

函数列表

- `initBoard`
- `addRandom`
- `drawBoard`
- `getInput`
- `moveByDirect(char)`
- `gameEnded`
- `showResult`



### 测试维护



## 第九课 - 函数

> 高内聚，低耦合
> High cohesion, low coupling



### 函数的组成

#### 函数

完成特定任务的程序代码的自包含单元（自力更生）

- 定义

```c
函数值类型
 |  函数名
 |   |   形式参数列表
 ↓   ↓       ↓
int sum(int a,int b){
    return a+b;
}
```

- 声明

原型声明，需要带参量类型，参量名可以省略



### 函数的调用

### 递归函数

Recursive Functions

调用自身的函数

- 每一级函数调用都有自己的变量，共用一个代码段

- 每次调用都会有一次返回

函数调用顺序

- 递归调用之前顺序执行
- 调用语句之后逆序执行

宏不能递归



递归的优缺点

- 优点，提供最简单的解决方法，结构优美
- 缺点，耗费计算机内存资源，限制计算规模，效率较低
- 解决方案
  - 自己实现栈，用最少的PUSH和POP操作
  - 设计矩阵保存已知的计算结果



高内聚低耦合

低耦合必然意味着高内聚

内聚是对模块内部特征而言的

耦合是多个模块组成系统中各模块关联关系而言的



函数设计注意事项

- 函数务必短小，25行80列

- 函数只做一件事

- 函数语句在同一个抽象层级上

- 函数参数要少，有足够理由才能使用三个以上的参数
- 描述性名称
  - 长名称比短名称好理解



打包进.h，用“balabala.h” include进来



## 期中考总结

- 在软件工程体系内都需要掌握
- 进制转换可以直接用`printf %x %o`
- 如果做到0%：
  - CE
    - 有没有编译才提交
  - RE
    - 访问野指针（没初始化，没开辟空间（malloc））
    - 除数为零
    - 内存溢出的厉害
    - 数组开太大
  - PR
    - 空格、空行
    - 用`freopen`输出
  - MLE
    - 数组开太大
    - 递归太多层爆栈（自己猜的）
  - TLE
    - 看运行窗口时间
  - WA
    - 有可能是没初始化（每个变量都要初始化）
    - 0%
      - 样例没过
      - （但是样例过了的怎么办？）
    - 10%
      - 一般只过了样例
      - 坑人的数据没那么多
      - **主要是对题目理解错了**
      - 重新读题，看看是不是跳步了，有些言下之意没读懂
    - 50%
      - 读题的程度有不同
      - **还是对题目理解错了**
    - 80-90%
      - 有人做对就可以判定为有坑
      - 要全测，用`freopen`



## 数组

### 声明

- 声明语句的方括号是修饰符，表达式的方括号是操作符
- 数组长度应为无符号整型常数，可以为0
- `const`，数组元素不可被修改，不可以用变量名改值，可以用写内存写
  - JAVA叫`final`
- 变量长度数组，很可能会错
- 先声明，再赋值，最后使用

### 初始化

- 声明时复合文字{}初始化
  - 未指定元素赋值为0
  - 数组长度不定，则以复合文字长度为准 `[] = {balabala}`
  - 写={}和写={0}实际上是一样的，明确说初始化了
- 声明后不能使用复合文字！
- 用循环语句初始化，特别是不需要初始化为0
- 用内存操作函数进行初始化为0
  - `memset`
  - 除0和-1外，不能用来赋其它值
  - 以字节为单位



### 断言

- assert(判断语句)





