# C程序设计

## 补充

**数组使用场景**

- 物理意义相同
- 数据类型相同
- 仅有次序区别

**循环使用场景**

- 流程大致相同
- 执行多次
- 有参数区别



## 第八课 - 输入输出与字符验证

### 输入输出缓冲

#### 单字符I/O

```c
ch = getchar();
new_ch = putchar(ch);


while((ch = getchar()) != '\n'){
    ……
}
```

getchar()有缓冲区，输入的数据放到缓冲区，直到输入回车才开始读入，且会读空白字符



#### 缓冲

是内存的一个取余，用于从一个地方移动到另一个位置时临时存储数据

协调吞吐速度差距很大的设备之间数据传送



#### 输入流

缓冲区默认为空

读一个删一个

已空后，若能补充缓冲则暂停等待，否则返回EOF继续冲虚

程序结束后，缓冲区释放



键盘缓冲区

程序缓冲区



#### 输入缓冲

##### 分类

完全缓冲，遇到缓冲区满就发送并清空（文件）

行缓冲，遇到回车时发送并清空（键盘）

##### 优缺点

允许用户在输入结束前发现错误，即使修改

减少调用输入输出的负担（数据库）

交互式程序需要非缓冲



#### 无缓冲输入流的行为

读取一个马上显示（存）一个



#### 输入输出流

（stream）

掩盖底层差异，提供统一接口

替用户和操作系统底层I/O打交道

四个操作，开open、关close、读read、写write

| 常见设备 | 标准流                                 | 打开     | 关闭 | 读取 | 写入 |
| -------- | -------------------------------------- | -------- | ---- | ---- | ---- |
| 屏幕     | 标准输出流stdout<br />标准错误流stderr | 自动打开 | 不可 | 不可 | 可   |
| 键盘     | 标准输入流stdin                        | 自动打开 | 可   | 可   | 不可 |
| 打印机   | 打印流                                 | 可       | 可   | 不可 | 可   |
| 文件     | 文件流                                 | 可       | 可   | 可   | 可   |
| 网络     | 网络流                                 | 可       | 可   | 可   | 可   |



#### 输入流终止

Ctrl+Z 终止键盘输入

Ctrl+C 终止程序终止键盘输入

返回EOF





```c
FILE * fp;
char fname[50];
fp = fopen(fname,"r");
getc(fp);
fclose(fp);
```



#### 流的重定向

用函数重定向到其他流



### 友好用户界面

软件工程更应该注重的地方

- 主体功能时基础

- 软件在用户各种可能的输入下不会崩溃也很重要

解决初级用户的输入错误

- 需要解决多余回车的问题

- 需要解决不慎按错键的问题



要用上`scanf`的返回值

可以用上assert函数：`assert(i-j-1>0 && i-j-1<N)`



## 2048游戏设计

## 作业要求

设计并实现一个2048游戏（大部分的需求都只有一句话）

作业——考核、承载老师对课程的理解

老师对程序设计的理解：

- 满足软件工程相关的思想

## 要求

### 需求分析

需求是不明确的

- 需要由需求分析人员和项目委托方共同完成

- 最终将明确需求为项目合同的附件，按期责功

方法

- 搜索相近产品，进一步细化需求
- 向项目委托方进一步确认

#### 要求

1. 2048有一个4*4棋盘
2. 开始时棋盘内随机出现两个数字，出现数字仅可能为2或4
3. 玩家可以选择上下左右四个方向，棋盘内棋子按该方向位移
   1. 若有棋子在移动方向一侧为空，则将其移动到该位
   2. 若有棋子在移动方向一侧为同样的数字，则将其相加，不可将两个以上数字相加
   3. 若该方向上无棋子满足1或2条件，则不移动棋子
4. 每有效移动一步，棋盘的空位随机出现一个数字（2或4）
5. 若四个方向都满足3.3条件，则判负
6. 若出现2048，则判胜



### 设计

#### 功能设计

**好的架构是进化来的，不是设计来的**

**测试指导编程**

数据结构：4*4矩阵变量

功能1：初始化棋盘，清空，出现两个值，可能为2或4

功能2：显示棋盘，两个for，打印数组，注意对齐

功能3：上下左右位移棋盘，只考虑位移

功能3.1：按行整理棋盘，用于左右位移

功能3.2：按行合并棋子

功能4：随机选择空位，随机增加一个棋子

功能5：判断胜负

#### 模块化设计

自顶向下

- 顶部架构设计，在一步步细化 

自底向上

- 先收集核心代码片段，一步步构造

双管齐下

- 两边同时进行



### 实现

走出第一步

```c
int main(){
    //initialize board
    //display board
    while(1){
        //add a number
        //move by input
        //fill blank
        //display board
        //if it is over, break
    }
    return 0;
}
```

完善框架

```c
int main(){
	initBoard();
    drawBoard();
    while(1){
        c = getInput();
        suc = moveByDirect(c);
        addRandom();
        drawBoard();
        if(gameEnded()){
            showResult();
            break;
        }
    }
    return 0;
}
```

函数列表

- `initBoard`
- `addRandom`
- `drawBoard`
- `getInput`
- `moveByDirect(char)`
- `gameEnded`
- `showResult`



### 测试维护



## 第九课 - 函数

> 高内聚，低耦合
> High cohesion, low coupling



### 函数的组成

#### 函数

完成特定任务的程序代码的自包含单元（自力更生）

- 定义

```c
函数值类型
 |  函数名
 |   |   形式参数列表
 ↓   ↓       ↓
int sum(int a,int b){
    return a+b;
}
```

- 声明

原型声明，需要带参量类型，参量名可以省略



### 函数的调用

### 递归函数

Recursive Functions

调用自身的函数

- 每一级函数调用都有自己的变量，共用一个代码段

- 每次调用都会有一次返回

函数调用顺序

- 递归调用之前顺序执行
- 调用语句之后逆序执行

宏不能递归



递归的优缺点

- 优点，提供最简单的解决方法，结构优美
- 缺点，耗费计算机内存资源，限制计算规模，效率较低
- 解决方案
  - 自己实现栈，用最少的PUSH和POP操作
  - 设计矩阵保存已知的计算结果



高内聚低耦合

低耦合必然意味着高内聚

内聚是对模块内部特征而言的

耦合是多个模块组成系统中各模块关联关系而言的



函数设计注意事项

- 函数务必短小，25行80列

- 函数只做一件事

- 函数语句在同一个抽象层级上

- 函数参数要少，有足够理由才能使用三个以上的参数
- 描述性名称
  - 长名称比短名称好理解



打包进.h，用“balabala.h” include进来



## 期中考总结

- 在软件工程体系内都需要掌握
- 进制转换可以直接用`printf %x %o`
- 如果做到0%：
  - CE
    - 有没有编译才提交
  - RE
    - 访问野指针（没初始化，没开辟空间（malloc））
    - 除数为零
    - 内存溢出的厉害
    - 数组开太大
  - PR
    - 空格、空行
    - 用`freopen`输出
  - MLE
    - 数组开太大
    - 递归太多层爆栈（自己猜的）
  - TLE
    - 看运行窗口时间
  - WA
    - 有可能是没初始化（每个变量都要初始化）
    - 0%
      - 样例没过
      - （但是样例过了的怎么办？）
    - 10%
      - 一般只过了样例
      - 坑人的数据没那么多
      - **主要是对题目理解错了**
      - 重新读题，看看是不是跳步了，有些言下之意没读懂
    - 50%
      - 读题的程度有不同
      - **还是对题目理解错了**
    - 80-90%
      - 有人做对就可以判定为有坑
      - 要全测，用`freopen`



## 数组

### 声明

- 声明语句的方括号是修饰符，表达式的方括号是操作符
- 数组长度应为无符号整型常数，可以为0
- `const`，数组元素不可被修改，不可以用变量名改值，可以用写内存写
  - JAVA叫`final`
- 变量长度数组，很可能会错
- 先声明，再赋值，最后使用

### 初始化

- 声明时复合文字{}初始化
  - 未指定元素赋值为0
  - 数组长度不定，则以复合文字长度为准 `[] = {balabala}`
  - 写={}和写={0}实际上是一样的，明确说初始化了
- 声明后不能使用复合文字！
- 用循环语句初始化，特别是不需要初始化为0
- 用内存操作函数进行初始化为0
  - `memset`
  - 除0和-1外，不能用来赋其它值
  - 以字节为单位



### 断言

- assert(判断语句)



11月23日

字符串排序有B站视频

OJ之后会加算法

**课前**



快就是慢，慢就是快

- 审题、实现、测试
- **想快，就是想偷懒**
- 跳过的偏偏是重要步骤
-  测试
  - 划测试类
  - 把所有定义域测出来
- 20%
  - 测试数据大部分不测
  - 没花心思到测试上



字符串

- \r
- \n
- \r\n
- EOF
- 尽量不用`getch`
  - 用gets+for是一个道理
- 学一下`fgets`
- 只说多了个回车，没有用



### 指针

数组声明后数组名是一个指针，是个常量，不可被赋值

指针变量赋值给指针常量表明不修改变量

指针常量赋值给指针变量是合法的，不推荐

- 可以绕道改const



指针的用途

- 生存周期之内，作用域之外
- 传数组的时候要记得把长度传进去
  - 用 `ar[]` 指明是数组（和 `*ar` 等价）
  - 传一个 `const int ar_lenth` 指明长度
- `*(a+i)` 等价于 `a[i]`



## 存储类 / 链接 / 内存管理

### 作用域

变量和函数名在代码中的使用范围

#### 文件作用域

- 在所有函数之外声明的变量或函数，在该文件内使用（全局变量）

#### 函数原型作用域

- 变长数组，`int n,int m,int ar[n][m]`

#### 函数作用域

- `goto`标签，对于函数内部可见

### 链接

变量和函数名是否可以被其它范围使用

空链接

外部链接

内部链接

### 存储时期

变量在内存中保留的时间

#### 静态存储时期

- 文件作用域的变量具有静态存储时期

- 声明时分配，程序退出前不释放
- static不表示静态存储时期，而是链接类型

#### 自动存储时期

- 进入代码块分配，退出则释放

### 存储类

按变量和函数的作用域和生存期划分类别

| 存储类             | 时期 | 作用域 | 链接 | 声明方式                       |
| ------------------ | ---- | ------ | ---- | ------------------------------ |
| 自动               | 自动 | 代码块 | 空   | 代码块内                       |
| 寄存器             | 自动 | 代码块 | 空   | 代码块，使用关键字static       |
| 具有外部链接的静态 | 静态 | 文件   | 外部 | 所有函数之外                   |
| 具有内部链接的静态 | 静态 | 文件   | 内部 | 所有函数之外，使用关键字static |
| 空链接的静态       | 静态 | 代码块 | 空   | 代码块内，使用关键字static     |

#### 自动变量

声明自动变量：auto

- 显式：auto 类型 变量名

- 隐式：类型 变量名

自动变化不会自动初始化，需要自行初始化

**内层同名会覆盖外层同名但不释放外层**

#### 内部链接静态变量

##### 声明静态变量：static

- 显式：static 类型 变量名

- 内存位置静态，值不是静态，不随着函数结束而消失和初始化

##### 初始化

- 声明的时候未初始化，则初始化为0
- 第一次用可以初始化
- 再次声明的时候不会被初始化

#### 外部链接的静态变量

引用的地方用extern

声明外部变量：extern

##### 位置

- 在一个文件的全局变量区域做定义声明

- 在用到该全局变量的其他文件里做引用声明

#### 存储类和函数

外部函数（默认）

内部（静态）函数，加一个static

不声明静态则为外部

### 随机函数

随机数

- 专门的随机试验的结果

伪随机数

- 用算法计算出均匀分布的随机数序列
- 具有随机数的统计特征，如均匀性，独立性

伪随机数发生器（PRNG）

- 种子为一个整数，确定伪随机数发生器的初始状态
- 当前状态运算得到新伪随机数，随后更新为新状态

发生种子，种子相同生成的随机数相同

动态内存分配

- 申请
  - `void *moalloc()`
  - `p = (int *)malloc(sizeof(int) * 60)`
  - 要包含`#include malloc.h`头文件
- 初始化
  - `void *memset(void *dest, int c, size_t count);`
  - 要包含`<memory.h> 或 <string.h>`
- 释放
  - free()
  - 由`malloc()`开辟的空间的释放要靠free
  - 开辟的空间如果不释放，会造成内存泄露

## 文件的输入输出

### 文件的基本概念

文件是磁盘上一段已命名的内存储区

- 物理上：可能分散在不同的区域里（操作系统管的）

- 逻辑上：程序可以认为这是一个连续的字节序列（文件流）

文件存取（读写）的最小单位是字节

文件的两种视图

- 二进制视图的存取最小单位是字节

- 文本视图存取的最小单位是字符

  - 读写时会将回车转换为本地类型

    | 操作系统 | 换行符 |
    | -------- | ------ |
    | Windows  | \r\n   |
    | Unix     | \n     |
    | Mac      | \r     |

低级I/O

- 操作系统提供的基本I/O

高级I/O

- 隐藏底层细节，提供统一接口
- 提供缓存功能，提高数据传输效率
  - 用内存做中转站，提速

接收命令行参数

- `int main(int argc,char *argv[])`
- 用双引号可以带空格传参

返回值

- 默认EXIT_SUCCESS或0表示程序终止
- 01返回值时，1表示成功
- 0或其他值时，0表示成功

### 文件的操作

- `fopen(const char *filename, const char *mode)`
- 文件指针FILE *
- 打开模式
  - 基本模式：r(读) w(写) a(追加模式)
  - 加强模式：r+(读写) w+(清空读写) a+(追加读写)
  - 文本模式：t(文本模式，默认) b(二进制模式)
- 关闭模式
  - `int fclose(FILE *stream)`
- 应该对文件开关读写的返回值进行处理

标准文件流

- 标准输入流
- 标准输出流
- 标准错误流
- `fprintf(stderr,"%s","balabala");`

文件读写

- 等价形式
  - `ch = getc(stdin)    ch = getchar()`
  - `putc(ch,stdout)    putchar(ch)`

- 一般文件指针放在最后

- 不定参数的函数，文件指针放前面
- 文件随机存取寻址fseek
- 文件随机存取查址ftell
- 

#### 开关读写

### 其他文件函数

fopen(文件名，模式)

fclose(指针)

fread(数组，单位，长度，文件)

fwrite 同上

fscanf(文件，格式，值列表)

fprintf 同上

fseek(文件，偏移，参考点)

ftell(文件)

## 结构体

### 结构体

基本数据类型无法表示的事物

- 整型
- 浮点型
- 数组
- 指针

图书

- 书名（字符串）
- 价格（浮点型）
- 页码（整数）

结构体类型

- 一组物理意义不同，数据类型不同，范畴相关的变量集合

结构体变量

- 称为对象（Object）

结构体中的变量

- 称为成员（Member）、属性（Attribute）、字段（Field）

修改结构体成员值的相关函数

- 称为方法（Method）

### 结构体声明

声明时必须指明标签名

- 未指定标签名的两个结构体变量不可相互赋值
  - 声明结构体类型和变量
  - 先声明结构体类型只声明结构体变量
  - 声明结构体类型和变量

### 结构体的意义

结构体提供了一个看待问题的视角

- 程序划分为数据和流程两个部分
- 数据按照类别定义为一个个对象
- 对象具有属性和方法（操作对象的函数）

高内聚，低耦合

- 面向对象

### 结构体变量的初始化

只能在声明时初始化，用复合文字



小测讲评

1.高内聚低耦合

2.全否

3.

冒泡

- 外层i:0~n-1
  - 内层0~n-1-i

选择

- 外层i:0~n-1
  - 内层i+i~n-1



结构体

传递结构体成员