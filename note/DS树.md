# 数据结构与算法





## 树

### 树的定义表示

- 递归性质

- 层次结构
  - 树的定义

    - n个结点的有限集合（n>=0）

    - 空树：n=0
- 根结点
  
    - 没有前驱的结点
- 前驱后继
  
    - n>1时，除根节点外的结点都有且只有一个前驱

    - 每个结点可以有若干个后继
- 递归定义，一棵树有若干棵互不相交的子树
  - 树的表示方法

    - 图
- 字符形式
  
  - 进一级加一个括号
    
  - 可做 #串 运算
    - 嵌套集合形式
- 凹入方式

### 树的基本概念

  - 树的结点

    - 包含一个数据元素及若干个指针
    
    - 这些指针指向其拥有子树的根
  
  - 结点的度
    - 结点拥有子树的个数
  
  - 叶结点（子结点）
    - 度=0的结点
  
  - 分支结点
    - 度>0的结点
  
  - 树的度 （宽度）
    - max（结点的度）
  
  - 结点的孩子
  
    - 该结点指针指向的结点
    
    - 结点拥有的子树的根
  
  - 孩子的双亲
    - 孩子节点的前驱（结点）
  
  - 兄弟结点
    - 同一个双亲结点的孩子
  
  - 结点的层次
  
    - 根结点定义为第一层
    
    - 根结点的孩子定义为第二层
    
    - 第l层结点的孩子定义为第l+1层
  
  - 树的高度/深度
    - max（结点层次）
  
  - 有序树&无序树
    - 按一定次序从左到右排列的树是有序树
  
  - 森林
    - 若干互不相交的树的有限集
  
  - 注意！
    - 树的高度 和 树的度 是不同概念！

  ## 二叉树

  - 定义
  
    - 结点的度<=2的有序树
    
    - 每个结点的子树最多2棵
  
  - 五种基本形态
  
    - 1. 空
    
    - 2. 单结点
    
    - 3. 根加左子树
    
    - 4. 根加右子树
    
    - 5. 根加左右子树

### 特殊二叉树

  - 满二叉树
    
  - 高度为k且具有2^k-1个结点的二叉树
    
  - 完全二叉树
  
    - 一颗高度为k，结点个数∈[2^(k-1),2^k-1]，第k层结点都集中在左侧的二叉树
    
    - 满二叉树也是完全二叉树

### 性质

  - 二叉树在第i层上最多有2^(i-1)个结点
    
    - 高度为k的二叉树最多有2^k-1个结点
    
    - 如果二叉树叶子节点的个数为n0，度数为2的节点数为n2，则n0=n2+1
      
    - 结点个数=边的条数+1
      
    - n个结点的完全二叉树的高度为 floor( log2(n) )+1
    
    - 完全二叉树（n结点）
    
      - 1. 编号i = 1：根结点
    
           编号i > 1：双亲编号floor(i/2)
    
      - 2. 结点i左孩子编号2i
    
           结点i右孩子编号2i+1
    
      - 3. 如果2i <= n，i为分支结点
    
           如果2i > n，i为叶子结点
    
      - 4. 如果n为奇数，则每个结点都有左右孩子
    
           如果n为偶数，则编号为n/2的分支结点（最大的分支结点）只有左孩子没有右孩子

### 顺序存储结构

  - 由上而下，由左往右进行顺序存放
  - 对一般的二叉树，用顺序存储会造成大量空间浪费
  - 适合完全二叉树

### 链式存储结构

  - 定义结点

```c
typedef struct Tnode{
Type data;
struct Tnode *lc;//左子树
struct Tnode *rc;//右子树
}Tnode,*Tree;
```

- 建树：给头结点malloc，指向子树的指针给NULL

- ```c
  InitTree(Tree &T)
  ```

- 补充：参数传递

- ```c
  swap(int a,int b)//分别给两个形式参数复制数，随着函数结束消失
  swap(int &a,int &b)//传两个地址给a和b的地址空间
  ```

- 读字符串并存入二叉树

  - data存一个字母
  - 左右孩子用，分隔
  - 只有左子树(a,) (a)
  - 只有右子树(,b)
- 实现
  - 字母模块，申结点空间，给该结点赋值，链入树中
  - 右子树则链入右，左子树则先链入后递归



## 期中考

11月10号周二下午考试

考试范围从绪论到树

简答题6 算法设计题4 总分100 折算20%



## 二叉树的遍历

逐个访问二叉树可视作化顺序表

### 先序遍历

DLR 根-左-右

字符型建树

Z字形

### 中序遍历

LDR 左-根-右

锯齿形

### 后序遍历

LRD 左-右-根

求树的高度

### 已知两遍历序列求原树

中序+先/后序：先找子树的根，分开左右子树

### 非递归遍历

```c++
//链栈
typedef struct SNode{
    Tree tnode;
    struct SNode *next;
}*Stark;

//其实就是把递归的栈自己写……会更快

int PreOrderS(Tree T){
	StackInit(S);
    p = T->lc;//根在T的左子
    while(p){
        while(p->lc){
            Visit(p);//向左走直接弹出父节点
            Push(S,p);
            p = p->lc;
        }
        Visit(p);
        while(!p->rc){
            Pop(S,p);
        }
        if(p->rc){
            p = p->rc;
        }
    }
}

int InOrder(Tree T){
    StackInit(S);
    p = T->lc;
    while(p){
        while(p->lc){
            Push(S,p);
            p = p->lc;
        }
        Visit(p);
        while(!p->rc){//左子树处理完了，可以弹出父节点
            Pop(S,p);
            Visit(p);
        }
        if(p->rc){
            p = p->rc;
        }
    }
}

//要用两个栈，往左找存左栈，找完弹一个到右栈，往右找完弹右栈
int PostOrder(Tree T){
    StackInit(L);
    StackInit(R);
    p = T->lc;
    while(p){
        while(p->lc){//一路向左压入左栈
            Push(L,p);
            p = p->lc;
        }
        while(!p->rc){//没有右子树，访问节点
            Visit(p);
            while(R->tnode->tc == p){//父节点右子树
                Pop(R,p);
                Visit(p);
            }
        }
        Pop(L,p);
        if(p->rc){
            Push(R,p);
            p = p->rc;
        }
    }
}
```



